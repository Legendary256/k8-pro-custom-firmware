var dfu={};!function(){"use strict";dfu.DETACH=0,dfu.DNLOAD=1,dfu.UPLOAD=2,dfu.GETSTATUS=3,dfu.CLRSTATUS=4,dfu.GETSTATE=5,dfu.ABORT=6,dfu.appIDLE=0,dfu.appDETACH=1,dfu.dfuIDLE=2,dfu.dfuDNLOAD_SYNC=3,dfu.dfuDNBUSY=4,dfu.dfuDNLOAD_IDLE=5,dfu.dfuMANIFEST_SYNC=6,dfu.dfuMANIFEST=7,dfu.dfuMANIFEST_WAIT_RESET=8,dfu.dfuUPLOAD_IDLE=9,dfu.dfuERROR=10,dfu.STATUS_OK=0,dfu.Device=function(e,t){this.device_=e,this.settings=t,this.intfNumber=t.interface.interfaceNumber},dfu.findDeviceDfuInterfaces=function(e){let t=[];for(let i of e.configurations)for(let r of i.interfaces)for(let n of r.alternates)254!=n.interfaceClass||1!=n.interfaceSubclass||1!=n.interfaceProtocol&&2!=n.interfaceProtocol||t.push({configuration:i,interface:r,alternate:n,name:n.interfaceName});return t},dfu.findAllDfuInterfaces=function(){return navigator.usb.getDevices().then(e=>{let t=[];for(let i of e){let r=dfu.findDeviceDfuInterfaces(i);for(let n of r)t.push(new dfu.Device(i,n))}return t})},dfu.Device.prototype.logDebug=function(e){},dfu.Device.prototype.logInfo=function(e){console.log(e)},dfu.Device.prototype.logWarning=function(e){console.log(e)},dfu.Device.prototype.logError=function(e){console.log(e)},dfu.Device.prototype.logProgress=function(e,t){console.log(typeof t>"u"?e:e+"/"+t)},dfu.Device.prototype.open=async function(){await this.device_.open();const e=this.settings.configuration.configurationValue;(null===this.device_.configuration||this.device_.configuration.configurationValue!=e)&&await this.device_.selectConfiguration(e);const t=this.settings.interface.interfaceNumber;this.device_.configuration.interfaces[t].claimed||await this.device_.claimInterface(t);const i=this.settings.alternate.alternateSetting;let r=this.device_.configuration.interfaces[t];(null===r.alternate||r.alternate.alternateSetting!=i)&&await this.device_.selectAlternateInterface(t,i)},dfu.Device.prototype.close=async function(){try{await this.device_.close()}catch(e){console.log(e)}},dfu.Device.prototype.readDeviceDescriptor=function(){return this.device_.controlTransferIn({requestType:"standard",recipient:"device",request:6,value:256,index:0},18).then(r=>"ok"==r.status?Promise.resolve(r.data):Promise.reject(r.status))},dfu.Device.prototype.readStringDescriptor=async function(e,t){typeof t>"u"&&(t=0);const s={requestType:"standard",recipient:"device",request:6,value:768|e,index:t};var o=await this.device_.controlTransferIn(s,1);if("ok"==o.status){const a=o.data.getUint8(0);if("ok"==(o=await this.device_.controlTransferIn(s,a)).status){const c=(a-2)/2;let u=[];for(let f=0;f<c;f++)u.push(o.data.getUint16(2+2*f,!0));return 0==t?u:String.fromCharCode.apply(String,u)}}throw`Failed to read string descriptor ${e}: ${o.status}`},dfu.Device.prototype.readInterfaceNames=async function(){let t={},i=new Set;for(let n=0;n<this.device_.configurations.length;n++){const s=await this.readConfigurationDescriptor(n);let o=dfu.parseConfigurationDescriptor(s),a=o.bConfigurationValue;t[a]={};for(let c of o.descriptors)4==c.bDescriptorType&&(c.bInterfaceNumber in t[a]||(t[a][c.bInterfaceNumber]={}),t[a][c.bInterfaceNumber][c.bAlternateSetting]=c.iInterface,c.iInterface>0&&i.add(c.iInterface))}let r={};for(let n of i)try{r[n]=await this.readStringDescriptor(n,1033)}catch(s){console.log(s),r[n]=null}for(let n in t)for(let s in t[n])for(let o in t[n][s])t[n][s][o]=r[t[n][s][o]];return t},dfu.parseDeviceDescriptor=function(e){return{bLength:e.getUint8(0),bDescriptorType:e.getUint8(1),bcdUSB:e.getUint16(2,!0),bDeviceClass:e.getUint8(4),bDeviceSubClass:e.getUint8(5),bDeviceProtocol:e.getUint8(6),bMaxPacketSize:e.getUint8(7),idVendor:e.getUint16(8,!0),idProduct:e.getUint16(10,!0),bcdDevice:e.getUint16(12,!0),iManufacturer:e.getUint8(14),iProduct:e.getUint8(15),iSerialNumber:e.getUint8(16),bNumConfigurations:e.getUint8(17)}},dfu.parseConfigurationDescriptor=function(e){let t=new DataView(e.buffer.slice(9)),i=dfu.parseSubDescriptors(t);return{bLength:e.getUint8(0),bDescriptorType:e.getUint8(1),wTotalLength:e.getUint16(2,!0),bNumInterfaces:e.getUint8(4),bConfigurationValue:e.getUint8(5),iConfiguration:e.getUint8(6),bmAttributes:e.getUint8(7),bMaxPower:e.getUint8(8),descriptors:i}},dfu.parseInterfaceDescriptor=function(e){return{bLength:e.getUint8(0),bDescriptorType:e.getUint8(1),bInterfaceNumber:e.getUint8(2),bAlternateSetting:e.getUint8(3),bNumEndpoints:e.getUint8(4),bInterfaceClass:e.getUint8(5),bInterfaceSubClass:e.getUint8(6),bInterfaceProtocol:e.getUint8(7),iInterface:e.getUint8(8),descriptors:[]}},dfu.parseFunctionalDescriptor=function(e){return{bLength:e.getUint8(0),bDescriptorType:e.getUint8(1),bmAttributes:e.getUint8(2),wDetachTimeOut:e.getUint16(3,!0),wTransferSize:e.getUint16(5,!0),bcdDFUVersion:e.getUint16(7,!0)}},dfu.parseSubDescriptors=function(e){let c,o=e,a=[],u=!1;for(;o.byteLength>2;){let f=o.getUint8(0),l=o.getUint8(1),d=new DataView(o.buffer.slice(0,f));if(4==l)c=dfu.parseInterfaceDescriptor(d),u=254==c.bInterfaceClass&&1==c.bInterfaceSubClass,a.push(c);else if(u&&33==l){let g=dfu.parseFunctionalDescriptor(d);a.push(g),c.descriptors.push(g)}else{let g={bLength:f,bDescriptorType:l,data:d};a.push(g),c&&c.descriptors.push(g)}o=new DataView(o.buffer.slice(f))}return a},dfu.Device.prototype.readConfigurationDescriptor=function(e){const r=512|e;return this.device_.controlTransferIn({requestType:"standard",recipient:"device",request:6,value:r,index:0},4).then(n=>{if("ok"==n.status){let s=n.data.getUint16(2,!0);return this.device_.controlTransferIn({requestType:"standard",recipient:"device",request:6,value:r,index:0},s)}return Promise.reject(n.status)}).then(n=>"ok"==n.status?Promise.resolve(n.data):Promise.reject(n.status))},dfu.Device.prototype.requestOut=function(e,t,i=0){return this.device_.controlTransferOut({requestType:"class",recipient:"interface",request:e,value:i,index:this.intfNumber},t).then(r=>"ok"==r.status?Promise.resolve(r.bytesWritten):Promise.reject(r.status),r=>Promise.reject("ControlTransferOut failed: "+r))},dfu.Device.prototype.requestIn=function(e,t,i=0){return this.device_.controlTransferIn({requestType:"class",recipient:"interface",request:e,value:i,index:this.intfNumber},t).then(r=>"ok"==r.status?Promise.resolve(r.data):Promise.reject(r.status),r=>Promise.reject("ControlTransferIn failed: "+r))},dfu.Device.prototype.detach=function(){return this.requestOut(dfu.DETACH,void 0,1e3)},dfu.Device.prototype.waitDisconnected=async function(e){let t=this,i=this.device_;return new Promise(function(r,n){let s;e>0&&(s=setTimeout(n,e)),navigator.usb.addEventListener("disconnect",function o(a){a.device===i&&(e>0&&clearTimeout(s),t.disconnected=!0,navigator.usb.removeEventListener("disconnect",o),a.stopPropagation(),r(t))})})},dfu.Device.prototype.download=function(e,t){return this.requestOut(dfu.DNLOAD,e,t)},dfu.Device.prototype.dnload=dfu.Device.prototype.download,dfu.Device.prototype.upload=function(e,t){return this.requestIn(dfu.UPLOAD,e,t)},dfu.Device.prototype.clearStatus=function(){return this.requestOut(dfu.CLRSTATUS)},dfu.Device.prototype.clrStatus=dfu.Device.prototype.clearStatus,dfu.Device.prototype.getStatus=function(){return this.requestIn(dfu.GETSTATUS,6).then(e=>Promise.resolve({status:e.getUint8(0),pollTimeout:16777215&e.getUint32(1,!0),state:e.getUint8(4)}),e=>Promise.reject("DFU GETSTATUS failed: "+e))},dfu.Device.prototype.getState=function(){return this.requestIn(dfu.GETSTATE,1).then(e=>Promise.resolve(e.getUint8(0)),e=>Promise.reject("DFU GETSTATE failed: "+e))},dfu.Device.prototype.abort=function(){return this.requestOut(dfu.ABORT)},dfu.Device.prototype.abortToIdle=async function(){await this.abort();let e=await this.getState();if(e==dfu.dfuERROR&&(await this.clearStatus(),e=await this.getState()),e!=dfu.dfuIDLE)throw"Failed to return to idle state after abort: state "+e.state},dfu.Device.prototype.do_upload=async function(e,t=1/0,i=0){let o,a,r=i,n=[],s=0;this.logInfo("Copying data from DFU device to browser"),this.logProgress(0);do{a=Math.min(e,t-s),o=await this.upload(a,r++),this.logDebug("Read "+o.byteLength+" bytes"),o.byteLength>0&&(n.push(o),s+=o.byteLength),Number.isFinite(t)?this.logProgress(s,t):this.logProgress(s)}while(s<t&&o.byteLength==a);return s==t&&await this.abortToIdle(),this.logInfo(`Read ${s} bytes`),new Blob(n,{type:"application/octet-stream"})},dfu.Device.prototype.poll_until=async function(e){let t,i=this;function r(n){return new Promise(function(s,o){i.logDebug("Sleeping for "+n+"ms"),setTimeout(s,n)})}do{for(let n=0;n<5;n++)try{t=await this.getStatus();break}catch{}await r(t.pollTimeout)}while(!e(t.state)&&t.state!=dfu.dfuERROR);return t},dfu.Device.prototype.poll_until_idle=function(e){return this.poll_until(t=>t==e)},dfu.Device.prototype.do_download=async function(e,t,i){let r=0,n=t.byteLength,s=0;for(this.logInfo("Copying data from browser to DFU device"),this.logProgress(r,n);r<n;){const a=Math.min(n-r,e);let u,c=0;try{c=await this.download(t.slice(r,r+a),s++),this.logDebug("Sent "+c+" bytes"),u=await this.poll_until_idle(dfu.dfuDNLOAD_IDLE)}catch(f){throw"Error during DFU download: "+f}if(u.status!=dfu.STATUS_OK)throw`DFU DOWNLOAD failed state=${u.state}, status=${u.status}`;this.logDebug("Wrote "+c+" bytes"),r+=c,this.logProgress(r,n)}this.logDebug("Sending empty block");try{await this.download(new ArrayBuffer([]),s++)}catch(o){throw"Error during final DFU download: "+o}if(this.logInfo("Wrote "+r+" bytes"),this.logInfo("Manifesting new firmware"),i){let o;try{if(o=await this.poll_until(a=>a==dfu.dfuIDLE||a==dfu.dfuMANIFEST_WAIT_RESET),o.state==dfu.dfuMANIFEST_WAIT_RESET&&this.logDebug("Device transitioned to MANIFEST_WAIT_RESET even though it is manifestation tolerant"),o.status!=dfu.STATUS_OK)throw`DFU MANIFEST failed state=${o.state}, status=${o.status}`}catch(a){if(!a.endsWith("ControlTransferIn failed: NotFoundError: Device unavailable.")&&!a.endsWith("ControlTransferIn failed: NotFoundError: The device was disconnected."))throw"Error during DFU manifest: "+a;this.logWarning("Unable to poll final manifestation status")}}else try{let o=await this.getStatus();this.logDebug(`Final DFU status: state=${o.state}, status=${o.status}`)}catch(o){this.logDebug("Manifest GET_STATUS poll error: "+o)}try{await this.device_.reset()}catch(o){if("NetworkError: Unable to reset the device."!=o&&"NotFoundError: Device unavailable."!=o&&"NotFoundError: The device was disconnected."!=o)throw"Error during reset for manifestation: "+o;this.logDebug("Ignored reset error")}}}();var dfuse={};!function(){"use strict";dfuse.GET_COMMANDS=0,dfuse.SET_ADDRESS=33,dfuse.ERASE_SECTOR=65,dfuse.Device=function(e,t){dfu.Device.call(this,e,t),this.memoryInfo=null,this.startAddress=NaN,t.name&&(this.memoryInfo=dfuse.parseMemoryDescriptor(t.name))},dfuse.Device.prototype=Object.create(dfu.Device.prototype),dfuse.Device.prototype.constructor=dfuse.Device,dfuse.parseMemoryDescriptor=function(e){const t=e.indexOf("/");if(!e.startsWith("@")||-1==t)throw`Not a DfuSe memory descriptor: "${e}"`;const i=e.substring(1,t).trim(),r=e.substring(t);let n=[];const s={" ":1,B:1,K:1024,M:1048576};let a,o=/\/\s*(0x[0-9a-fA-F]{1,8})\s*\/(\s*[0-9]+\s*\*\s*[0-9]+\s?[ BKM]\s*[abcdefg]\s*,?\s*)+/g;for(;a=o.exec(r);){let f,c=/([0-9]+)\s*\*\s*([0-9]+)\s?([ BKM])\s*([abcdefg])\s*,?\s*/g,u=parseInt(a[1],16);for(;f=c.exec(a[0]);){let l={},d=parseInt(f[1],10),g=parseInt(f[2])*s[f[3]],h=f[4].charCodeAt(0)-"a".charCodeAt(0)+1;l.start=u,l.sectorSize=g,l.end=u+g*d,l.readable=0!=(1&h),l.erasable=0!=(2&h),l.writable=0!=(4&h),n.push(l),u+=g*d}}return{name:i,segments:n}},dfuse.Device.prototype.dfuseCommand=async function(e,t,i){typeof t>"u"&&typeof i>"u"&&(t=0,i=1);const r={0:"GET_COMMANDS",33:"SET_ADDRESS",65:"ERASE_SECTOR"};let n=new ArrayBuffer(i+1),s=new DataView(n);if(s.setUint8(0,e),1==i)s.setUint8(1,t);else{if(4!=i)throw"Don't know how to handle data of len "+i;s.setUint32(1,t,!0)}try{await this.download(n,0)}catch(a){throw"Error during special DfuSe command "+r[e]+":"+a}if((await this.poll_until(a=>a!=dfu.dfuDNBUSY)).status!=dfu.STATUS_OK)throw"Special DfuSe command "+commandName+" failed"},dfuse.Device.prototype.getSegment=function(e){if(!this.memoryInfo||!this.memoryInfo.segments)throw"No memory map information available";for(let t of this.memoryInfo.segments)if(t.start<=e&&e<t.end)return t;return null},dfuse.Device.prototype.getSectorStart=function(e,t){if(typeof t>"u"&&(t=this.getSegment(e)),!t)throw`Address ${e.toString(16)} outside of memory map`;const i=Math.floor((e-t.start)/t.sectorSize);return t.start+i*t.sectorSize},dfuse.Device.prototype.getSectorEnd=function(e,t){if(typeof t>"u"&&(t=this.getSegment(e)),!t)throw`Address ${e.toString(16)} outside of memory map`;const i=Math.floor((e-t.start)/t.sectorSize);return t.start+(i+1)*t.sectorSize},dfuse.Device.prototype.getFirstWritableSegment=function(){if(!this.memoryInfo||!this.memoryInfo.segments)throw"No memory map information available";for(let e of this.memoryInfo.segments)if(e.writable)return e;return null},dfuse.Device.prototype.getMaxReadSize=function(e){if(!this.memoryInfo||!this.memoryInfo.segments)throw"No memory map information available";let t=0;for(let i of this.memoryInfo.segments)if(i.start<=e&&e<i.end){if(!i.readable)return 0;t+=i.end-e}else if(i.start==e+t){if(!i.readable)break;t+=i.end-i.start}return t},dfuse.Device.prototype.erase=async function(e,t){let i=this.getSegment(e),r=this.getSectorStart(e,i);const n=this.getSectorEnd(e+t-1);let s=0;const o=n-r;for(o>0&&this.logProgress(s,o);r<n;){if(i.end<=r&&(i=this.getSegment(r)),!i.erasable){s=Math.min(s+i.end-r,o),r=i.end,this.logProgress(s,o);continue}const a=Math.floor((r-i.start)/i.sectorSize),c=i.start+a*i.sectorSize;this.logDebug(`Erasing ${i.sectorSize}B at 0x${c.toString(16)}`),await this.dfuseCommand(dfuse.ERASE_SECTOR,c,4),r=c+i.sectorSize,s+=i.sectorSize,this.logProgress(s,o)}},dfuse.Device.prototype.do_download=async function(e,t,i){if(!this.memoryInfo||!this.memoryInfo.segments)throw"No memory map available";this.logInfo("Erasing DFU device memory");let r=0,n=t.byteLength,s=this.startAddress;isNaN(s)?(s=this.memoryInfo.segments[0].start,this.logWarning("Using inferred start address 0x"+s.toString(16))):null===this.getSegment(s)&&this.logError(`Start address 0x${s.toString(16)} outside of memory map bounds`),await this.erase(s,n),this.logInfo("Copying data from browser to DFU device");let o=s;for(;r<n;){const c=Math.min(n-r,e);let f,u=0;try{await this.dfuseCommand(dfuse.SET_ADDRESS,o,4),this.logDebug(`Set address to 0x${o.toString(16)}`),u=await this.download(t.slice(r,r+c),2),this.logDebug("Sent "+u+" bytes"),f=await this.poll_until_idle(dfu.dfuDNLOAD_IDLE),o+=c}catch(l){throw"Error during DfuSe download: "+l}if(f.status!=dfu.STATUS_OK)throw`DFU DOWNLOAD failed state=${f.state}, status=${f.status}`;this.logDebug("Wrote "+u+" bytes"),r+=u,this.logProgress(r,n)}this.logInfo(`Wrote ${r} bytes`),this.logInfo("Manifesting new firmware");try{await this.dfuseCommand(dfuse.SET_ADDRESS,s,4),await this.download(new ArrayBuffer,0)}catch(a){throw"Error during DfuSe manifestation: "+a}try{await this.poll_until(a=>a==dfu.dfuMANIFEST)}catch(a){this.logError(a)}},dfuse.Device.prototype.do_upload=async function(e,t){let i=this.startAddress;return isNaN(i)?(i=this.memoryInfo.segments[0].start,this.logWarning("Using inferred start address 0x"+i.toString(16))):null===this.getSegment(i)&&this.logWarning(`Start address 0x${i.toString(16)} outside of memory map bounds`),this.logInfo(`Reading up to 0x${t.toString(16)} bytes starting at 0x${i.toString(16)}`),await this.getState()!=dfu.dfuIDLE&&await this.abortToIdle(),await this.dfuseCommand(dfuse.SET_ADDRESS,i,4),await this.abortToIdle(),await dfu.Device.prototype.do_upload.call(this,e,t,2)}}();